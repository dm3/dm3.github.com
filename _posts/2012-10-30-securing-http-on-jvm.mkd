---
layout: post
title: Securing HTTP on the JVM
---

Suppose you have a server providing an API through the HTTP protocol and a
known set of clients which should be allowed to access the server. What is the
best way of authenticating clients and securing the API at the same time?

The standard way to secure HTTP is through upgrading the protocol to HTTPS
(HTTP Secure). HTTPS is widely used in the internet (mainly by browsers) to
verify sites identities and to encrypt all of the communication happening
between the server and the client. Less known fact is that HTTPS allows for
client authentication by the server as well as server authentication by the
client - also called mutual auth.

# HTTPS in detail

HTTPS is the same old HTTP transmitted in a secure way through the TLS
<sup><a href="#1">1</a></sup> channel.  In the case of HTTP clients and servers,
TCP is usually used as the transport layer protocol in order to guarantee
reliability.  However, TLS has also been implemented over other transport-level
protocols like UDP or DCCP<sup><a href="#2">2</a></sup>.

To give a better high-level view, the following diagram shows how all of the
protocols come together in the network stack:

![Network layers](/post_img/network-layers.png)

When an HTTP client expresses an intent to communicate with an HTTP server over
TLS, the following steps happen<sup><a href="#3">3</a></sup>:

![TLS handshake](/post_img/wordy-tls.png)

That's quite a bunch of new terms! To figure out what's actually happening
during a handshake, we ought to have a grip on the most significant terms used
in the client-server conversation: public and private keys, certificates and
cipher suites. Each of these terms is a huge topic by itself. In this post we
will cover the absolute minimum needed to understand how these elements work
together in order to provide a secure environment.

## Public and private keys

Public/private key technology is what underlines the cryptosystem of HTTPS<sup><a href="#4">4</a></sup>.

![Public and private key](/post_img/public-private-keys.png)

The main idea of a public/private key pair is that any message encrypted using
a public key can later be decrypted only using the private key of the same key
pair. Public keys, as stems from their name, are distributed publicly, while
private keys must always be kept in secret.  Exposure of a private key always
leads to security breaches and major headaches for people supporting the
security infrastructure.

From a practical point of view a public/private key is just a string of bytes
kept in a file. Usually the bytes are encoded in a human-readable characters
(Base64) to facilitate easier sharing. For example, a public key generated
with `ssh-keygen`, looks like this:

    ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDjPgT2BBP0pCS5fZ4geP8rgbs0hxJq4bV55aCs
    Sfp6OJP9DaRZchq3Fmp7BtAG/MMDwWvD/Wrhf7Wl7gsyTAzFY8rHjIAAY5mUQfOjVX2gLRsc5KNJ
    nKhOKiqTbm2s3Du0Fi9qrxu1LEG74LWNyRbW2T08NusFcBr4lCCHsZZSP74n2ju9aj1f5RBcEQtW
    0/GG72cawptb//ZMvyPEjoUY0zhnp91fTrl33ckHU9e/omR3AtlCh2BX8x3+DhEG9dY3uEK7C1Mn
    OOHRfu7X+R9w2ZY6au2upnUoyFkN89ELoIevsUDtUeG0i+d59qP9sVgHUTIFNC60wBwswSe/56Hz
    dm3@dm3

The corresponding private key is longer but just as confusing for human eyes.
You can generate keypairs like this any time you want, but once you start using
a pair, remember - a private key must always be kept in secret.

If you ever used `SSH` or `Github` or any other developer tool which requires
security, you've probably bumped into the instructions on how to generate a
public/private key pair. Without understanding how keys work you'll see that
you keep coming back and re-reading instructions every time you have to use a
secure mechanism. I encourage you to familiarize yourself with tools used to
generate and manage public/private keys on your platform of choice.

## Certificates

In layman terms a digital certificate is just a public key associated with an
identity - information such as a name or email. The association is performed
by signing the public key and the identity with a digital signature.

Now you might wonder, who has the authority to create digital signatures? The
answer is - anyone. However, a certificate signed by a malicious party doesn't
mean much as the receiver of the certificate is capable of verifying whether
the signer is trusted.

Verification is possible because the signature of the certificate is extracted
from the private key of the signer. This way we can always know whether the
certificate was signed by the authority we trust (meaning we already trust the
certificate of the signer).

All of the diagrams were done in the free [Diagram.ly](http://diagram.ly) tool.

------------------------------------------------------
1. &#x20;<a id="1">&nbsp;</a>I will use TLS instead of SSL/TLS everywhere because TLS has
   mostly superseded SSL on the web. You may see TLS and SSL used
   interchangeably or in a union (like SSL/TLS). The truth is - both of these
   protocols are still in use with their latest versions being insignificantly
   (for this post) different. For a complete treatment you can refer to
   [this serverfault post](http://serverfault.com/questions/178561/what-are-the-exact-protocol-level-differences-between-ssl-and-tls/179139#179139)
   and
   [Eric Rescorla's book - SSL and TLS: Designing and Building Secure Systems, Addison-Wesley, 2001 ISBN 0-201-61598-3](http://www.rtfm.com/sslbook/)
2. &#x20;<a id="2">&nbsp;</a>[TLS Applications](http://en.wikipedia.org/wiki/Transport_Layer_Security#Applications).
3. &#x20;<a id="3">&nbsp;</a>This is also a simplification. Refer to the
   [Wikipedia article on TLS](http://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_handshake_in_detail)
   for the full handshake protocol in all of the flavours. Also I encourage you to read the post on
   [Moserware](http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html)
   for an in-depth look at the communication which occurs during a handshake.
4. &#x20;<a id="4">&nbsp;</a>[Wikipedia on Public Key Cryptography](http://en.wikipedia.org/wiki/Public-key_cryptography)
